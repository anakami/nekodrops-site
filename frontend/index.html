<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NEKO DROPS 🌸</title>
  
  <!-- Meta tags -->
  <meta property="og:title" content="NEKO DROPS 🌸">
  <meta property="og:description" content="Best methods and Drops 🩷">
  <meta property="og:image" content="https://i.imgur.com/inRRoT6.jpeg">
  <meta property="og:url" content="https://i.imgur.com/inRRoT6.jpeg">
  <meta property="og:type" content="website">
  <meta name="theme-color" content="#FF69B4">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="NEKO DROPS 🌸">
  <meta name="twitter:description" content="Best methods and Drops 🩷">
  <meta name="twitter:image" content="https://i.imgur.com/inRRoT6.jpeg">
  
  <!-- Favicon -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌸</text></svg>">
  
  <!-- Fontes e ícones -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <!-- CSS personalizado -->
  <link rel="stylesheet" href="style.css">
  
  <!-- Socket.io -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
  <!-- Partículas Kawaii -->
  <div class="kawaii-particle" style="top: 10%; left: 5%;">🌸</div>
  <div class="kawaii-particle" style="top: 20%; right: 8%;">🐱</div>
  <div class="kawaii-particle" style="top: 40%; left: 8%;">✨</div>
  <div class="kawaii-particle" style="top: 60%; right: 12%;">🦄</div>
  <div class="kawaii-particle" style="top: 80%; left: 15%;">🌟</div>

  <div id="connection-status" class="connection-status">❌ Desconectado</div>

  <div class="container">
    <header>
      <div class="logo">NEKO <span>DROPS</span> 🐱</div>
      <button class="mobile-menu-btn">☰</button>
      <div class="auth-section">
        <div id="user-info" class="user-info hidden">
          <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
          <span id="username"></span>
        </div>
        <button id="login-btn" class="login-btn">🎮 Entrar com Discord</button>
      </div>
    </header>

    <div class="filters">
      <button class="filter-btn active" data-filter="all">🌸 All Accs</button>
      <button class="filter-btn" data-filter="normal">😼 Normal Acc</button>
      <button class="filter-btn" data-filter="vip">✨ VIP Acc</button>
      <button class="filter-btn" data-filter="methods">🥞 Métodos</button>
    </div>

    <div id="drops-container">
      <div class="drops-grid" id="drops-grid">
        <div class="loading"><div class="loading-spinner"></div></div>
      </div>
    </div>

    <div id="load-more-container" class="load-more-container hidden">
      <button id="load-more-btn" class="load-more-btn">
          <i class="fas fa-chevron-down"></i>🍭 Ver Mais
      </button>
     </div>
    
    <div class="footer">
      <p>neko drops © by Anna 🌸</p>
    </div>
  </div>

  <div id="login-modal" class="modal">
    <div class="modal-content">
      <h2 class="modal-title">🎮 Entrar com Discord</h2>
      <p>Para acessar as contas fofinhas, você precisa fazer login com sua conta do Discord e ser membro do nosso servidor! 🐾</p>
      <button id="modal-login-btn" class="modal-btn">✨ Continuar com Discord</button>
    </div>
  </div>

  <div id="error-modal" class="modal">
    <div class="modal-content">
      <h2 class="modal-title">😿 Erro de Acesso</h2>
      <p id="error-message">Você precisa ser membro do servidor para acessar as contas fofinhas!</p>
      <button class="modal-btn" id="error-close-btn">Fechar</button>
    </div>
  </div>

  <script>
  let banCheckInterval = null;
  let membershipCheckInterval = null;

  const CLIENT_ID = "1410654667490197641";
  const SERVER_ID = "1420183845646503988";
  const MEMBER_ROLE_ID = "1420541777076686968";
  const VIP_ROLE_ID = "1420540428792631336";
  const OWNER_ROLE_ID = "1420536814422327541";
  const BOOSTER_ROLE_ID = "1422261539938898000";
  const BACKEND_URL = 'https://nekodrops-backend.onrender.com';

  /* Elementos */
  const loginBtn = document.getElementById('login-btn');
  const userInfo = document.getElementById('user-info');
  const userAvatar = document.getElementById('user-avatar');
  const username = document.getElementById('username');
  const dropsGrid = document.getElementById('drops-grid');
  const loginModal = document.getElementById('login-modal');
  const errorModal = document.getElementById('error-modal');
  const errorMessage = document.getElementById('error-message');
  const errorCloseBtn = document.getElementById('error-close-btn');
  const modalLoginBtn = document.getElementById('modal-login-btn');
  const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
  const filters = document.querySelector('.filters');
  const connectionStatus = document.getElementById('connection-status');
// Variáveis para paginação
  const DROPS_PER_PAGE = 50;
  let allDrops = []; // Todas as drops disponíveis
  let displayedDrops = []; // Drops atualmente exibidas
  let currentPage = 1;
    
  let user = null, userRoles = [], drops = [], socket = null;
  let currentFilter = 'all';

  /* Helper: limpa texto e normaliza "N/A" */
  function cleanDiscordText(text) {
    if (text === undefined || text === null) return "";
    const s = String(text).replace(/```/g, "").trim();
    if (!s) return "";
    if (s.toLowerCase() === 'n/a') return "";
    return s;
  }

function extractIPFromLink(text) {
  if (!text) return "";
  
  console.log('📋 Texto original para extrair IP:', text);
  
  // 1. Primeiro tenta encontrar IPs em formatos markdown: [IP](link)
  const markdownMatch = text.match(/\[([\d\.]+)\]\([^)]+\)/);
  if (markdownMatch && markdownMatch[1]) {
    console.log('✅ IP encontrado em markdown:', markdownMatch[1]);
    return markdownMatch[1];
  }
  
  // 2. Tenta encontrar IPs em links: IP: 181.119.67.38
  const ipWithLabel = text.match(/(?:IP|ip)[:\s]*([\d\.]{7,15})/i);
  if (ipWithLabel && ipWithLabel[1]) {
    console.log('✅ IP encontrado com label:', ipWithLabel[1]);
    return ipWithLabel[1];
  }
  
  // 3. Tenta encontrar IPs soltos no texto
  const ipRegex = /(\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b)/;
  const ipMatch = text.match(ipRegex);
  if (ipMatch && ipMatch[1]) {
    console.log('✅ IP encontrado com regex:', ipMatch[1]);
    return ipMatch[1];
  }
  
  // 4. Tenta encontrar em formatos de lista: • IP: 181.119.67.38
  const listMatch = text.match(/[•\-*]\s*(?:IP|ip)[:\s]*([\d\.]{7,15})/i);
  if (listMatch && listMatch[1]) {
    console.log('✅ IP encontrado em lista:', listMatch[1]);
    return listMatch[1];
  }
  
  // 5. Tenta encontrar em formatos com emojis: 🌐 181.119.67.38
  const emojiMatch = text.match(/[🌐🖥️💻]\s*([\d\.]{7,15})/);
  if (emojiMatch && emojiMatch[1]) {
    console.log('✅ IP encontrado com emoji:', emojiMatch[1]);
    return emojiMatch[1];
  }
  
  console.log('❌ Nenhum IP encontrado no texto');
  return text;
}

async function checkMethodsPermissions() {
  const token = localStorage.getItem('discord_token');
  if (!token) return null;
  
  try {
    const response = await fetch(`${BACKEND_URL}/api/user-methods-permissions`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    if (response.ok) {
      const data = await response.json();
      return data.success ? data.permissions : null;
    }
  } catch (error) {
    console.error('Erro ao verificar permissões:', error);
  }
  return null;
}

// Função para redirecionar para métodos
async function redirectToMethods() {
  const permissions = await checkMethodsPermissions();
  
  if (permissions && permissions.canSeeMethods) {
    window.location.href = 'metodos/booster.html';
  } else {
    window.location.href = 'metodos/no-access.html';
  }
 }


// Função para verificar se o usuário está banido
async function checkIfUserIsBanned() {
  if (!user || !user.id) return false;
  
  try {
    const token = localStorage.getItem('discord_token');
    const response = await fetch(`${BACKEND_URL}/api/check-ban/${user.id}`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    if (response.ok) {
      const data = await response.json();
      if (data.banned) {
        // Usuário está banido - deslogar
        showError("❌ Você foi banido do servidor");
        setTimeout(() => logout(), 3000);
        return true;
      }
    }
    return false;
  } catch (error) {
    console.error("Erro ao verificar banimento:", error);
    return false;
  }
}

// Função para verificar se o usuário ainda está no servidor
async function checkGuildMembership() {
  if (!user || !user.id) return false;
  
  try {
    const token = localStorage.getItem('discord_token');
    const response = await fetch(`${BACKEND_URL}/api/check-membership/${user.id}`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    if (response.ok) {
      const data = await response.json();
      if (!data.isMember) {
        // Usuário não está mais no servidor - deslogar
        showError("❌ Você não é mais membro do servidor");
        setTimeout(() => logout(), 3000);
        return false;
      }
      return true;
    }
    return false;
  } catch (error) {
    console.error("Erro ao verificar membership:", error);
    return false;
  }
}

// Iniciar verificações periódicas
function startPeriodicChecks() {
  // Verificar a cada 2 minutos
  banCheckInterval = setInterval(checkIfUserIsBanned, 120000);
  membershipCheckInterval = setInterval(checkGuildMembership, 120000);
}

// Parar verificações
function stopPeriodicChecks() {
  if (banCheckInterval) clearInterval(banCheckInterval);
  if (membershipCheckInterval) clearInterval(membershipCheckInterval);
}


    
function saveDropsToLocalStorage() {
  try {
    const dataToSave = {
      allDrops: allDrops,
      timestamp: Date.now(),
      version: 'v2' // Adiciona versão para futuras migrações
    };
    localStorage.setItem('nekodrops_data', JSON.stringify(dataToSave));
  } catch (e) {
    console.error('Erro ao salvar drops no localStorage:', e);
  }
}

function loadDropsFromLocalStorage() {
  try {
    const savedData = localStorage.getItem('nekodrops_data');
    if (!savedData) return [];
    
    const parsedData = JSON.parse(savedData);
    
    // ✅ CORREÇÃO: Verificar ambas as possibilidades (drops e allDrops)
    let dropsData = [];
    
    if (parsedData.version === 'v2') {
      const age = Date.now() - parsedData.timestamp;
      if (age < 24 * 60 * 60 * 1000) {
        // Tenta carregar de 'drops' primeiro, depois de 'allDrops'
        dropsData = parsedData.drops || parsedData.allDrops || [];
      }
    } else {
      // Estrutura antiga
      const age = Date.now() - parseInt(localStorage.getItem('nekodrops_timestamp') || '0');
      if (age < 24 * 60 * 60 * 1000) {
        dropsData = JSON.parse(savedData) || [];
      }
    }
    
    return dropsData;
  } catch (e) {
    console.error('Erro ao carregar drops do localStorage:', e);
    return [];
  }
}
    
function clearDropsFromLocalStorage() {
  try {
    localStorage.removeItem('nekodrops_data');
    localStorage.removeItem('nekodrops_drops');
    localStorage.removeItem('nekodrops_timestamp');
  } catch (e) {
    console.error('Erro ao limpar drops do localStorage:', e);
  }
}

// Função para migrar dados antigos (executar uma vez)
function migrateOldStorage() {
  try {
    const oldDrops = localStorage.getItem('nekodrops_drops');
    const oldTimestamp = localStorage.getItem('nekodrops_timestamp');
    
    if (oldDrops && !localStorage.getItem('nekodrops_data')) {
      const dataToSave = {
        drops: JSON.parse(oldDrops),
        timestamp: parseInt(oldTimestamp || Date.now().toString()),
        version: 'v2'
      };
      localStorage.setItem('nekodrops_data', JSON.stringify(dataToSave));
    }
  } catch (e) {
    console.error('Erro na migração do storage:', e);
  }
}

async function syncWithServer() {
  try {
    const token = localStorage.getItem('discord_token');
    if (!token) return;
    
    const response = await fetch(`${BACKEND_URL}/api/drops`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    if (response.ok) {
      const data = await response.json();
      if (data.success) {
        // Atualizar apenas se houver novas drops
        if (data.drops.length !== allDrops.length) {
          allDrops = data.drops;
          saveDropsToLocalStorage();
          renderDrops(currentFilter);
          console.log('🔄 Drops sincronizadas com o servidor');
        }
      }
    }
  } catch (error) {
    console.log('⚠️ Erro na sincronização:', error);
  }
}

// Sincronizar a cada 5 minutos
setInterval(syncWithServer, 5 * 60 * 1000);

    
// Função para gerenciar a paginação
function setupPagination() {
  const loadMoreContainer = document.getElementById('load-more-container');
  const loadMoreBtn = document.getElementById('load-more-btn');
  
  if (!loadMoreContainer || !loadMoreBtn) return;
  
  loadMoreBtn.addEventListener('click', loadMoreDrops);
}

// Função para carregar mais drops
function loadMoreDrops() {
  currentPage++;
  renderDrops(currentFilter);
}

// Função para verificar se há mais drops para carregar
function hasMoreDrops() {
  const startIndex = (currentPage - 1) * DROPS_PER_PAGE;
  return startIndex + DROPS_PER_PAGE < allDrops.length;
}

// Função para atualizar a visibilidade do botão "Ver Mais"
function updateLoadMoreButton() {
  const loadMoreContainer = document.getElementById('load-more-container');
  const loadMoreBtn = document.getElementById('load-more-btn');
  
  if (!loadMoreContainer || !loadMoreBtn) return;
  
  if (hasMoreDrops()) {
    loadMoreContainer.classList.remove('hidden');
    loadMoreBtn.disabled = false;
  } else {
    loadMoreContainer.classList.add('hidden');
  }
    }
    

  /* Delegação: copiar valores */
  function setupCopyButtons() {
    document.addEventListener('click', e => {
      if (e.target.classList.contains('copy-btn')) {
        const value = e.target.getAttribute('data-value') || '';
        if (value) {
          navigator.clipboard.writeText(value).then(() => {
            const originalText = e.target.textContent;
            e.target.textContent = '✨ Copiado!';
            setTimeout(() => {
              e.target.textContent = originalText;
            }, 2000);
          });
        }
      }
    });
  }

// function ip
    
const countryCache = new Map();

function isValidIP(ip) {
  if (!ip || typeof ip !== 'string') return false;
  
  const cleanedIp = ip.trim();
  if (cleanedIp === 'N/A' || cleanedIp === '' || cleanedIp === 'undefined') return false;
  
  const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!ipv4Pattern.test(cleanedIp)) return false;
  
  const parts = cleanedIp.split('.');
  return parts.every(part => {
    const num = parseInt(part, 10);
    return !isNaN(num) && num >= 0 && num <= 255;
  });
}

async function getCountryFromIP(ip) {
  // Verificar se é um IP válido
  if (!isValidIP(ip)) {
    const invalidIP = {
      code: 'invalid',
      name: 'IP inválido',
      flag: null
    };
    countryCache.set(ip, invalidIP);
    return invalidIP;
  }
  
  // Verificar cache
  if (countryCache.has(ip)) {
    return countryCache.get(ip);
  }

  try {
    console.log('🌍 Buscando país para IP:', ip);
    
    // ✅ NOVA API: ipinfo.io (mais confiável e com free tier)
    // ✅ ALTERNATIVA: ipapi.com (também boa)
    const apis = [
      `https://ipinfo.io/${ip}/json?token=test`, // Sem token, funciona para poucas requisições
      `https://ipapi.co/${ip}/json/`,
      `https://json.geoiplookup.io/${ip}`
    ];
    
    let countryInfo = null;
    
    // Tentar cada API até uma funcionar
    for (const apiUrl of apis) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 2000);
        
        const response = await fetch(apiUrl, {
          signal: controller.signal,
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json'
          }
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
          const data = await response.json();
          
          // Processar resposta baseado na API
          if (data.country) {
            // ipinfo.io format
            countryInfo = {
              code: data.country.toLowerCase(),
              name: data.country_name || data.country,
              flag: `https://flagcdn.com/w40/${data.country.toLowerCase()}.png`,
              country: data.country_name || data.country,
              city: data.city,
              region: data.region
            };
          } else if (data.country_code) {
            // ipapi.co format
            countryInfo = {
              code: data.country_code.toLowerCase(),
              name: data.country_name || data.country,
              flag: `https://flagcdn.com/w40/${data.country_code.toLowerCase()}.png`,
              country: data.country_name || data.country,
              city: data.city,
              region: data.region
            };
          } else if (data.country_code) {
            // geoiplookup format
            countryInfo = {
              code: data.country_code.toLowerCase(),
              name: data.country_name,
              flag: `https://flagcdn.com/w40/${data.country_code.toLowerCase()}.png`,
              country: data.country_name,
              city: data.city,
              region: data.region
            };
          }
          
          if (countryInfo) break; // Se encontrou, para o loop
        }
      } catch (error) {
        console.log(`❌ API ${apiUrl} falhou:`, error.message);
        continue; // Tenta a próxima API
      }
    }
    
    if (!countryInfo) {
      throw new Error('Todas as APIs falharam');
    }
    
    console.log('✅ País encontrado:', countryInfo.name, 'para IP:', ip);
    
    // Salvar no cache
    countryCache.set(ip, countryInfo);
    
    return countryInfo;
    
  } catch (error) {
    console.log('❌ Erro ao buscar país do IP:', ip, error.message);
    
    // Fallback: usar API local via backend
    try {
      console.log('🔄 Tentando via backend...');
      const response = await fetch(`${BACKEND_URL}/api/ip-info?ip=${ip}`);
      if (response.ok) {
        const data = await response.json();
        if (data.success) {
          countryCache.set(ip, data.countryInfo);
          return data.countryInfo;
        }
      }
    } catch (backendError) {
      console.log('❌ Backend também falhou:', backendError.message);
    }
    
    // Fallback final
    const fallback = {
      code: 'unknown',
      name: 'Desconhecido',
      flag: null
    };
    
    countryCache.set(ip, fallback);
    return fallback;
  }
}

// Função para forçar atualização de um IP específico
async function refreshIPInfo(ip) {
  countryCache.delete(ip);
  return await getCountryFromIP(ip);
}

/* Função para criar elemento de IP com bandeira */
function createIPWithFlagElement(ip, countryInfo) {
  const container = document.createElement('div');
  container.className = 'ip-with-flag';
  
  container.innerHTML = `
    <span class="credential-value">${ip}</span>
    ${countryInfo.flag ? `
      <img src="${countryInfo.flag}" alt="${countryInfo.name}" class="country-flag" 
           onerror="this.style.display='none'">
      <span class="country-name">${countryInfo.name}</span>
    ` : ''}
  `;
  
  return container;
}


  /* WebSocket */
function setupWebSocket() {
  socket = io(BACKEND_URL, { transports: ['websocket', 'polling'] });

  socket.on('connect', () => {
    console.log('✅ WebSocket conectado');
    const token = localStorage.getItem('discord_token');
    if (token) {
      socket.emit('authenticate', { token });
    }
  });

  // Adicione esta função para atualizar as roles quando o WebSocket se conectar
  socket.on('authenticated', (data) => {
  connectionStatus.textContent = '✨ Conectado';
  connectionStatus.classList.add('connected');
  
  // ✅ CORREÇÃO: Atualizar userRoles se vierem do servidor
  if (data && data.roles) {
    userRoles = data.roles;
    console.log('🔄 Roles atualizadas via WebSocket:', userRoles);
  }
});

 socket.on('user_banned', (data) => {
  if (user && data.userId === user.id) {
    showError("❌ Você foi banido do servidor");
    setTimeout(() => {
      logout();
      window.location.href = 'banned.html';
    }, 3000);
  }
});


 socket.on('user_left', (data) => {
  if (user && data.userId === user.id) {
    showError("❌ Você saiu do servidor");
    setTimeout(() => logout(), 3000);
  }
});

  
  socket.on('auth_error', (err) => {
    console.warn('❌ Erro de autenticação WS:', err?.message || 'desconhecido');
    connectionStatus.textContent = '⚠️ Não autenticado';
    connectionStatus.classList.remove('connected');
  });

  socket.on('disconnect', () => {
    connectionStatus.textContent = '❌ Desconectado';
    connectionStatus.classList.remove('connected');
  });

  socket.on('new-drop', dropData => {
  // ✅ CORREÇÃO: Verificar permissões com dados atuais do usuário
  const canSeeVip = userRoles.includes(VIP_ROLE_ID) || userRoles.includes(OWNER_ROLE_ID);
  const canSee = !dropData.isVip || canSeeVip;
  
  if (canSee) {
    allDrops.unshift(dropData);
    saveDropsToLocalStorage();
    renderDrops(currentFilter);
    console.log('🎉 Novo drop recebido e exibido');
  } else {
    console.log('🔒 Drop VIP bloqueado - usuário sem permissão');
  }
});

  socket.on('drop-deleted', id => { 
    allDrops = allDrops.filter(d => d.id !== id); 
    saveDropsToLocalStorage();
    renderDrops(currentFilter); 
  });
}
  /* Carrega drops do servidor */
async function loadDropsFromServer() {
  try {
    const token = localStorage.getItem('discord_token');
    const headers = token ? { 'Authorization': `Bearer ${token}` } : {};
    
    const res = await fetch(`${BACKEND_URL}/api/drops`, { headers });
    const data = await res.json();
    
    if (data.success) {
      allDrops = data.drops; // ✅ CORREÇÃO: Usar data.drops em vez de data.allDrops
      currentPage = 1;
      saveDropsToLocalStorage();
      console.log('📥 Drops carregadas do servidor:', allDrops.length);
    } else {
      console.error('Erro ao carregar drops do servidor:', data.error);
    }
  } catch (e) {
    console.error('Erro ao carregar drops do servidor:', e);
  }
  renderDrops(currentFilter);
}
  /* Event listeners básicos (login modal, login button) */
  function setupEventListeners() {
    if (loginBtn) {
      loginBtn.addEventListener('click', () => {
        if (user) logout(); else {
          loginModal.style.display = 'flex';
          document.body.style.overflow = 'hidden';
        }
      });
    }
    if (modalLoginBtn) {
      modalLoginBtn.addEventListener('click', e => { e.preventDefault(); loginWithDiscord(); });
    }
  }

  function setupModalClosing() {
    document.addEventListener('click', e => {
      if (e.target === loginModal || e.target === errorModal) {
        loginModal.style.display = 'none';
        errorModal.style.display = 'none';
        document.body.style.overflow = 'auto';
      }
    });
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        loginModal.style.display = 'none';
        errorModal.style.display = 'none';
        document.body.style.overflow = 'auto';
      }
    });
    if (errorCloseBtn) errorCloseBtn.addEventListener('click', () => {
      errorModal.style.display = 'none';
      document.body.style.overflow = 'auto';
    });
  }

  function setupMobileMenu() {
    if (!mobileMenuBtn || !filters) return;
    mobileMenuBtn.addEventListener('click', e => {
      e.stopPropagation(); 
      filters.classList.toggle('active');
    });
    document.addEventListener('click', e => {
      if (!e.target.closest('.filters') && !e.target.closest('.mobile-menu-btn')) {
        filters.classList.remove('active');
      }
    });
    window.addEventListener('resize', () => {
      if (window.innerWidth > 768) filters.classList.remove('active');
    });
  }

  function checkAuth() {
    const token = localStorage.getItem('discord_token');
    const userData = localStorage.getItem('discord_user');
    const rolesData = localStorage.getItem('discord_roles');

    if (token && userData) {
        user = JSON.parse(userData);
        if (rolesData) userRoles = JSON.parse(rolesData);
        
        if (userRoles.length > 0) { 
            updateUIAfterLogin(); 
            loadDropsFromServer();
        } else {
            // Verificar cargos se não tiver
            checkUserRoles(token);
        }
    } else {
        showNoAccessMessage();
    }
}
// Função para verificar cargos
async function checkUserRoles(token) {
    try {
        const response = await fetch(`${BACKEND_URL}/api/user-roles`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            userRoles = data.roles || [];
            localStorage.setItem('discord_roles', JSON.stringify(userRoles));
            updateUIAfterLogin();
            loadDropsFromServer();
        }
    } catch (error) {
        console.error("Erro ao verificar roles:", error);
    }
}
  
/* Auth flow (simplificado e corrigido) */
function loginWithDiscord() {
  if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
    // iOS - usa redirecionamento direto
    window.location.href = `${BACKEND_URL}/auth/discord`;
  } else {
    // Outros dispositivos - usa popup
    const authWindow = window.open(
      `${BACKEND_URL}/auth/discord`,
      'DiscordLogin',
      'width=600,height=700'
    );
  }
}

function processAuthResponse() {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    const error = urlParams.get('error');

    if (error) {
        showError("Erro no login: " + error);
        return;
    }

    if (token) {
        // Salvar token
        localStorage.setItem('discord_token', token);
        
        // Limpar URL
        window.history.replaceState({}, document.title, window.location.pathname);
        
        // Buscar informações do usuário
        fetchUserInfo(token);
    }
}

async function fetchUserInfo(token) {
  try {
    const response = await fetch(`${BACKEND_URL}/api/user-info`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    // 🔹 Novo: tratamento específico para usuários banidos
    if (response.status === 403) {
      const err = await response.json();
      if (err.banned) {
        showError("❌ Você foi banido do servidor");
        setTimeout(() => {
          logout();
          window.location.href = 'banned.html';
        }, 3000);
        return; // não continua o login
      }
    }

    if (response.ok) {
      const userData = await response.json();

      user = {
        id: userData.userId || '',
        username: userData.username || 'Usuário',
        avatar: userData.avatar || null,
        discriminator: userData.discriminator || '0000'
      };

      userRoles = userData.roles || [];

      localStorage.setItem('discord_user', JSON.stringify(user));
      localStorage.setItem('discord_roles', JSON.stringify(userRoles));

      updateUIAfterLogin();
      loadDropsFromServer();
    } else {
      // outros erros genéricos
      throw new Error('Falha ao obter informações do usuário');
    }
  } catch (error) {
    console.error('Erro ao buscar informações:', error);
    showError("Erro ao carregar informações do usuário");
    logout();
  }
}

// Sistema de segurança anti-hack
let securityCheckInterval = null;

function initSecuritySystem() {
  // Verificação periódica de segurança
  securityCheckInterval = setInterval(() => {
    checkUserAuthorization();
    validateLocalStorage();
  }, 30000); // A cada 30 segundos
  
  // Monitorar tentativas de acesso ao localStorage
  monitorLocalStorageAccess();
  
  console.log('🔒 Sistema de segurança ativado');
}

function checkUserAuthorization() {
  const token = localStorage.getItem('discord_token');
  const userData = localStorage.getItem('discord_user');
  
  if (!token || !userData) {
    // Usuário não logado - limpar dados sensíveis
    clearSensitiveData();
    return;
  }
  
  // Verificar se o usuário ainda tem permissão
  verifyUserPermissions(token).catch(() => {
    clearSensitiveData();
  });
}

async function verifyUserPermissions(token) {
  try {
    const response = await fetch(`${BACKEND_URL}/api/user-roles`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    if (!response.ok) throw new Error('Token inválido');
    
    const data = await response.json();
    const userRoles = data.roles || [];
    
    // Se não for mais VIP, limpar dados VIP
    const isVip = userRoles.includes(VIP_ROLE_ID) || userRoles.includes(OWNER_ROLE_ID);
    if (!isVip) {
      clearVipData();
    }
  } catch (error) {
    throw error;
  }
}

function clearSensitiveData() {
  // Limpar apenas dados sensíveis, mantendo drops normais
  const savedData = localStorage.getItem('nekodrops_data');
  if (savedData) {
    try {
      const parsedData = JSON.parse(savedData);
      // Manter apenas drops não-VIP
      if (parsedData.drops && Array.isArray(parsedData.drops)) {
        parsedData.drops = parsedData.drops.filter(drop => !drop.isVip);
        localStorage.setItem('nekodrops_data', JSON.stringify(parsedData));
      }
    } catch (e) {
      console.error('Erro ao limpar dados sensíveis:', e);
    }
  }
  
  // Forçar re-render para remover VIPs da interface
  if (currentFilter === 'vip' || currentFilter === 'all') {
    renderDrops(currentFilter);
  }
}

function clearVipData() {
  // Limpar apenas dados VIP
  const savedData = localStorage.getItem('nekodrops_data');
  if (savedData) {
    try {
      const parsedData = JSON.parse(savedData);
      // Remover drops VIP
      if (parsedData.drops && Array.isArray(parsedData.drops)) {
        parsedData.drops = parsedData.drops.filter(drop => !drop.isVip);
        localStorage.setItem('nekodrops_data', JSON.stringify(parsedData));
        allDrops = parsedData.drops;
      }
    } catch (e) {
      console.error('Erro ao limpar dados VIP:', e);
    }
  }
  
  // Atualizar interface
  renderDrops(currentFilter);
}

function validateLocalStorage() {
  // Verificar integridade dos dados
  try {
    const savedData = localStorage.getItem('nekodrops_data');
    if (savedData) {
      JSON.parse(savedData); // Isso vai lançar erro se não for JSON válido
    }
  } catch (e) {
    console.warn('Dados corrompidos no localStorage, limpando...');
    localStorage.removeItem('nekodrops_data');
    window.location.reload();
  }
}

function monitorLocalStorageAccess() {
  // Monitorar tentativas de acesso direto ao localStorage
  const originalSetItem = localStorage.setItem;
  const originalGetItem = localStorage.getItem;
  
  localStorage.setItem = function(key, value) {
    if (key === 'nekodrops_data' && typeof value === 'string') {
      try {
        JSON.parse(value); // Validar JSON
      } catch (e) {
        console.warn('Tentativa de inserir dados inválidos bloqueada');
        return;
      }
    }
    return originalSetItem.apply(this, arguments);
  };
  
  localStorage.getItem = function(key) {
    if (key === 'nekodrops_data') {
      // Registrar acesso para debugging
      console.log('Acesso aos dados de drops detectado');
    }
    return originalGetItem.apply(this, arguments);
  };
}

  
async function updateUserUI() {
  const token = localStorage.getItem('discord_token');
  if (!token) {
    loginBtn.textContent = '🎮 Entrar com Discord';
    userInfo.classList.add('hidden');
    return;
  }

  try {
    const res = await fetch(`${BACKEND_URL}/api/user-info`, {
      headers: { Authorization: `Bearer ${token}` }
    });
    const data = await res.json();

    if (data.success) {
      // Salvar no estado e localStorage
      user = { id: data.userId, username: data.username, avatar: data.avatar };
      userRoles = data.roles || [];
      localStorage.setItem('discord_user', JSON.stringify(user));
      localStorage.setItem('discord_roles', JSON.stringify(userRoles));

      // Atualizar UI
      loginBtn.textContent = '🚪 Sair';
      username.textContent = user.username;
      userAvatar.src = `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.png?size=128`;
      userInfo.classList.remove('hidden');

      // Autenticar socket
      if (socket && socket.connected) {
        socket.emit('authenticate', { token });
      }
    } else {
      logout();
    }
  } catch (e) {
    console.error("Erro ao buscar usuário:", e);
    logout();

  }
}
    
  async function getUserInfo(token) {
    try {
      const res = await fetch(`${BACKEND_URL}/api/user-info`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (!res.ok) { 
        logout(); 
        return; 
      }
      
      const data = await res.json();
      
      if (!data.canAccess) { 
        showError("Você precisa ser membro do servidor."); 
        logout(); 
        return; 
      }
      
      user = { 
        id: data.userId, 
        username: data.username, 
        avatar: data.avatar 
      };
      
      userRoles = data.roles || [];
      localStorage.setItem('discord_user', JSON.stringify(user));
      localStorage.setItem('discord_roles', JSON.stringify(userRoles));
      updateUIAfterLogin(); 
      loadDropsFromServer(); // Carrega do servidor após login
    } catch (e) {
      console.error("Erro ao obter informações do usuário:", e);
      showError("Erro ao carregar informações do usuário.");
    }
  }

async function loadFlagsForIPs() {
  const flagPlaceholders = document.querySelectorAll('.flag-placeholder');
  
  for (const placeholder of flagPlaceholders) {
    const ip = placeholder.getAttribute('data-ip');
    
    if (ip && ip !== 'N/A' && ip.trim() !== '') {
      try {
        // Mostrar loading
        placeholder.innerHTML = '<span class="country-name">Carregando...</span>';
        
        const countryInfo = await getCountryFromIP(ip);
        
        if (countryInfo.flag && countryInfo.code !== 'error' && countryInfo.code !== 'invalid') {
          placeholder.innerHTML = `
            <img src="${countryInfo.flag}" alt="${countryInfo.name}" 
                 class="country-flag" onerror="this.style.display='none'">
            <span class="country-name">${countryInfo.name}</span>
          `;
        } else {
          placeholder.innerHTML = `<span class="country-name">${countryInfo.name}</span>`;
        }
        
      } catch (error) {
        console.log('❌ Erro ao carregar bandeira para IP:', ip, error);
        placeholder.innerHTML = '<span class="country-name">Desconhecido</span>';
      }
    } else {
      placeholder.innerHTML = '<span class="country-name">IP inválido</span>';
    }
  }
}


function updateUIAfterLogin() {
  loginBtn.textContent = '🚪 Sair';
  
  if (user) {
    username.textContent = user.username;
    
    // ✅ CORREÇÃO: Verificar se tem avatar e usar fallback
    if (user.avatar) {
      userAvatar.src = `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.png?size=128`;
    } else {
      // Fallback para avatar padrão do Discord
      const defaultAvatarNumber = user.discriminator % 5;
      userAvatar.src = `https://cdn.discordapp.com/embed/avatars/${defaultAvatarNumber}.png`;
    }
  }
  
  userInfo.classList.remove('hidden'); 
  loginModal.style.display = 'none';
  document.body.style.overflow = 'auto';

  startPeriodicChecks();
    
  // Reautenticar WebSocket
  if (socket && socket.connected) {
    socket.emit('authenticate', {
      userId: user.id,
      roles: userRoles
    });
  }
}

  function logout() {
  stopPeriodicChecks();
  localStorage.clear();
  clearDropsFromLocalStorage();
  user = null; 
  userRoles = [];
  loginBtn.textContent = '🎮 Entrar com Discord';
  userInfo.classList.add('hidden'); 
  localStorage.removeItem('discord_token');
  updateUserUI();
  clearDrops(); 
  showNoAccessMessage();
  if (socket) { 
    socket.disconnect(); 
    connectionStatus.textContent = '❌ Desconectado'; 
    connectionStatus.classList.remove('connected'); 
  }
}

  function showError(msg) {
    errorMessage.textContent = msg; 
    errorModal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
  }

  /* UI: render */
function renderDrops(filter = 'all') {
  clearDrops();
  
  if (!user || userRoles.length === 0) { 
    showNoAccessMessage(); 
    return; 
  }

  const canSeeVip = userRoles.includes(VIP_ROLE_ID) || userRoles.includes(OWNER_ROLE_ID);
  const isOwner = userRoles.includes(OWNER_ROLE_ID);
  
  // 🔒 VERIFICAÇÃO DE SEGURANÇA EXTRA
  if (filter === 'vip' && !canSeeVip) {
    // Double-check: mesmo que o usuário tente forçar, não mostrar VIPs
    showNoVipAccessMessage();
    // Limpar qualquer dado VIP que possa ter vazado
    clearVipData();
    return;
  }
  
  // Filtrar drops com base nas permissões reais
  let filtered = allDrops.filter(drop => {
    if (drop.isVip && !canSeeVip) return false;
    return true;
  });
  
  // Aplicar filtro adicional se necessário
  if (filter === 'normal') {
    filtered = filtered.filter(d => !d.isVip);
  } else if (filter === 'vip') {
    filtered = filtered.filter(d => d.isVip);
  }
  
  if (!filtered.length) {
    showNoDropsMessage(filter);
    return;
  }
  
  // Calcular quantas drops mostrar
  const startIndex = 0;
  const endIndex = currentPage * DROPS_PER_PAGE;
  const dropsToShow = filtered.slice(startIndex, endIndex);
  
  // Renderizar as drops
  dropsToShow.forEach(d => {
    const element = createRobloxAccountElement(d, isOwner);
    if (element) {
      dropsGrid.appendChild(element);
    }
  });
  
  loadFlagsForIPs();

    
  updateLoadMoreButton();
}

  /* Função central: cria o card respeitando os diferentes tipos de embed */
  function createRobloxAccountElement(account, isOwner) {
    const card = document.createElement('div');
    card.className = 'drop-card'; 
    card.dataset.id = account.id;

    // Normaliza valores e considera "N/A" como ausente
    const usernameVal = cleanDiscordText(account.username);
    const passwordVal = cleanDiscordText(account.password);
    const ipVal = cleanDiscordText(account.ip);
    const cookieVal = cleanDiscordText(account.cookie);
    const authVal = cleanDiscordText(account.authenticator || account.auth);
    const recoveryVal = cleanDiscordText(account.recovery || account.recovery_codes || account.recoveryCodes);

    const cleanIpVal = extractIPFromLink(ipVal);
    console.log('✅ IP extraído:', cleanIpVal);

    const isValidIp = isValidIP(cleanIpVal);
    console.log('🎯 IP válido?', isValidIp);
    
    // Detecta tipo com precedência (auth > cookie+ip > ip-only > username+password)
    let type = 'basic';
    if (authVal) type = 'auth';
    else if (cookieVal && ipVal) type = 'primary';
    else if (ipVal) type = 'ip';
    else if (usernameVal && passwordVal) type = 'credentials';

    // Cabeçalho / imagem
    const imageUrl = account.imageUrl || account.image || account.thumbnail || '';
    const title = usernameVal || "Conta Roblox";
    const robux = cleanDiscordText(account.robux) || "";
    const age = cleanDiscordText(account.age) || "";

    // Monta credenciais dependendo do tipo
    let credentialsHTML = '';

    // Usuário sempre aparece se existir
    if (usernameVal) {
      credentialsHTML += `
        <div class="credential-item">
          <span>👤 Usuário: </span><span class="credential-value">${usernameVal}</span>
          <button class="copy-btn" data-value="${usernameVal}">Copiar</button>
        </div>`;
    }

    // Senha aparece se existir
    if (passwordVal) {
      credentialsHTML += `
        <div class="credential-item">
          <span>🔑 Senha: </span><span class="credential-value">••••••••</span>
          <button class="copy-btn" data-value="${passwordVal}">Copiar</button>
        </div>`;
    }

if (type === 'primary') {
  if (cleanIpVal) {
    credentialsHTML += `
      <div class="credential-item">
        <span>🌐 IP: </span>
        <div class="ip-with-flag">
          <span class="credential-value">${cleanIpVal}</span>
          <div class="flag-placeholder" data-ip="${cleanIpVal}">
            <span class="country-name">Carregando...</span>
          </div>
        </div>
        <button class="copy-btn" data-value="${cleanIpVal}">Copiar</button>
      </div>`;
  }
      if (cookieVal) {
        credentialsHTML += `
          <div class="credential-item">
            <span>🍪 Cookie: </span><span class="credential-value">••••••••</span>
            <button class="copy-btn" data-value="${cookieVal}">Copiar</button>
          </div>`;
      }
    }

    // Tipo auth: Auth + Recovery Codes + Cookie
    if (type === 'auth') {
      if (authVal) {
        credentialsHTML += `
          <div class="credential-item">
            <span>📱 Auth: </span><span class="credential-value">••••••••</span>
            <button class="copy-btn" data-value="${authVal}">Copiar</button>
          </div>`;
      }
      if (recoveryVal) {
        credentialsHTML += `
          <div class="credential-item">
            <span>🔓 Recovery: </span><span class="credential-value">••••••••</span>
            <button class="copy-btn" data-value="${recoveryVal}">Copiar</button>
          </div>`;
      }
      if (cookieVal) {
        credentialsHTML += `
          <div class="credential-item">
            <span>🍪 Cookie: </span><span class="credential-value">••••••••</span>
            <button class="copy-btn" data-value="${cookieVal}">Copiar</button>
          </div>`;
      }
    }

// Tipo ip: apenas IP
if (type === 'ip' && cleanIpVal) {
  credentialsHTML += `
    <div class="credential-item">
      <span>🌐 IP: </span>
      <div class="ip-with-flag">
        <span class="credential-value">${cleanIpVal}</span>
        <div class="flag-placeholder" data-ip="${cleanIpVal}">
          <span class="country-name">Carregando...</span>
        </div>
      </div>
      <button class="copy-btn" data-value="${cleanIpVal}">Copiar</button>
    </div>`;
}

    // Tipo credentials: apenas username e password (já adicionados acima)
    // Se não houver credenciais, mostra mensagem
    if (!credentialsHTML) {
      credentialsHTML = `<div class="credential-item"><span class="credential-value">😿 Sem credenciais disponíveis</span></div>`;
    }

    // Features da conta
    const features = (account.features && Array.isArray(account.features) && account.features.length > 0)
      ? account.features.map(f => `<li>${cleanDiscordText(f)}</li>`).join('')
      : '';

    card.innerHTML = `
      ${account.isVip ? '<div class="vip-badge">✨ VIP</div>' : '<div class="drop-badge">🐾 ROBLOX</div>'}
      ${imageUrl ? `<img src="${imageUrl}" alt="${title}" class="drop-image">` : ''}
      <div class="drop-content">
        <h3 class="drop-title">${title}</h3>
        ${robux || age ? `<div class="drop-price">${robux ? robux + " Robux" : ""} ${age ? "• " + age : ""}</div>` : ''}
        ${features ? `<ul class="drop-features">${features}</ul>` : ''}
        <div class="account-credentials">
          ${credentialsHTML}
        </div>
        ${account.description ? `<div class="drop-description">${cleanDiscordText(account.description)}</div>` : ''}
        <div class="drop-footer">
          <button class="claim-btn">🎮 Resgatar Agora</button>
          ${isOwner ? '<button class="delete-btn">🗑️</button>' : ''}
        </div>
      </div>
    `;

    // Deletar (se for owner)
    if (isOwner) {
      const del = card.querySelector('.delete-btn');
      if (del) {
        del.addEventListener('click', () => {
          const confirmMsg = `Deletar "${usernameVal || title}"?`;
          if (confirm(confirmMsg)) deleteDrop(account.id);
        });
      }
    }

    // Botão de resgatar
    const claimBtn = card.querySelector('.claim-btn');
    if (claimBtn) {
      claimBtn.addEventListener('click', () => {
        alert(`🎉 Conta "${usernameVal || title}" resgatada com sucesso!`);
      });
    }

    return card;
  }

function loadDrops() {
  loadDropsFromServer();
}
    
  /* Delete drop (usa token se disponível) */
  async function deleteDrop(id) {
    try {
      const token = localStorage.getItem('discord_token');
      const headers = token ? { 'Authorization': `Bearer ${token}` } : {};
      const res = await fetch(`${BACKEND_URL}/api/drops/${id}`, { method: 'DELETE', headers });
      
      if (!res.ok) throw new Error('Erro ao deletar');
      
      allDrops = allDrops.filter(d => d.id !== id);
      saveDropsToLocalStorage(); // Atualiza localStorage após deletar
      renderDrops(currentFilter);
    } catch (e) {
      console.error(e);
      showError('Erro ao deletar');
    }
  }

  /* utilidades UI */
  function clearDrops() { 
    dropsGrid.innerHTML = ''; 
  }

function showNoAccessMessage() {
  const loadMoreContainer = document.getElementById('load-more-container');
  if (loadMoreContainer) {
    loadMoreContainer.classList.add('hidden');
  }
  
  dropsGrid.innerHTML = `
    <div class="no-drops">
      <h3>😿 Acesso Restrito</h3>
      <p>Você precisa fazer login e ser membro do servidor para visualizar as contas fofinhas!</p>
    </div>
  `;
}

function showNoVipAccessMessage() {
  const loadMoreContainer = document.getElementById('load-more-container');
  if (loadMoreContainer) {
    loadMoreContainer.classList.add('hidden');
  }
  
  dropsGrid.innerHTML = `
    <div class="no-drops">
      <h3>✨ Acesso VIP Necessário</h3>
      <p>Você precisa ser VIP para visualizar as contas VIP fofinhas!</p>
    </div>
  `;
}

function showNoDropsMessage(filter = 'all') {
  const loadMoreContainer = document.getElementById('load-more-container');
  if (loadMoreContainer) {
    loadMoreContainer.classList.add('hidden');
  }
  
  dropsGrid.innerHTML = `
    <div class="no-drops">
      <h3>😿 Nenhuma conta disponível</h3>
      <p>${filter === 'vip' ? 'Não há contas VIP fofinhas disponíveis no momento.' : 'Volte mais tarde para ver novas contas fofinhas!'}</p>
    </div>
  `;
}

  /* filtros */
  function setupFilters() {
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      if (btn.dataset.filter === 'methods') {
        redirectToMethods();
        return;
      }
      
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentFilter = btn.dataset.filter;
      renderDrops(currentFilter);
    });
  });
}

document.addEventListener('DOMContentLoaded', () => {
  // Migrar dados antigos primeiro
  migrateOldStorage();
  
  // Configurações iniciais
  setupFilters();
  setupEventListeners();
  setupCopyButtons();
  setupModalClosing();
  setupMobileMenu();
  setupPagination();
  
  const savedDrops = loadDropsFromLocalStorage();
  if (savedDrops.length > 0) {
    allDrops = savedDrops;
    renderDrops(currentFilter);
    setTimeout(() => loadFlagsForIPs(), 1000);
  }
  
  // Verifica autenticação e processa resposta
  checkAuth();
  processAuthResponse();
  setupWebSocket();
  
  // Inicia sistema de segurança
  setTimeout(initSecuritySystem, 2000);
});
  </script>
</body>
</html>
