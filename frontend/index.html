<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEKO DROPS</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap">
    <link rel="stylesheet" href="style.css">
    <!-- Socket.io CDN para WebSocket -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 1000;
            font-size: 12px;
            background: #f44336;
            color: white;
        }
        .connection-status.connected {
            background: #4CAF50;
        }
        .drop-notification {
            position: fixed;
            top: 50px;
            right: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 999;
            max-width: 250px;
            font-size: 14px;
            animation: slideIn 0.3s ease;
        }
        @keyframes slideIn {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Status de conexão WebSocket -->
    <div id="connection-status" class="connection-status">
        ❌ Desconectado
    </div>

    <div class="container">
        <header>
            <div class="logo">NEKO <span>DROPS</span></div>
            <button class="mobile-menu-btn">☰</button>
            <div class="auth-section">
                <div id="user-info" class="user-info hidden">
                    <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                    <span id="username"></span>
                </div>
                <button id="login-btn" class="login-btn">Entrar com Discord</button>
            </div>
        </header>
        
        <div class="filters">
            <button class="filter-btn active" data-filter="all">Todas as Contas</button>
            <button class="filter-btn" data-filter="normal">Contas Normais</button>
            <button class="filter-btn" data-filter="vip">Contas VIP</button>
        </div>
        
        <div id="drops-container">
            <div class="drops-grid" id="drops-grid">
                <div class="loading">
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="login-modal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">Entrar com Discord</h2>
            <p>Para acessar as contas, você precisa fazer login com sua conta do Discord e ser membro do nosso servidor.</p>
            <button id="modal-login-btn" class="modal-btn">Continuar com Discord</button>
        </div>
    </div>

    <div id="error-modal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">Erro de Acesso</h2>
            <p id="error-message">Você precisa ser membro do servidor para acessar as contas.</p>
            <button class="modal-btn" id="error-close-btn">Fechar</button>
        </div>
    </div>

    <script>
        // Configurações - URLs do backend no Render
        const CLIENT_ID = "1410654667490197641";
        const REDIRECT_URI = "https://nekodrops-site.onrender.com/";
        const SERVER_ID = "1399661543284805763";
        const MEMBER_ROLE_ID = "1399662113114296360";
        const VIP_ROLE_ID = "1399662852448587859";
        const OWNER_ROLE_ID = "1399664650638856303";

        const BACKEND_URL = 'https://nekodrops-backend.onrender.com';

        // Elementos DOM
        const loginBtn = document.getElementById('login-btn');
        const userInfo = document.getElementById('user-info');
        const userAvatar = document.getElementById('user-avatar');
        const username = document.getElementById('username');
        const dropsGrid = document.getElementById('drops-grid');
        const loginModal = document.getElementById('login-modal');
        const errorModal = document.getElementById('error-modal');
        const errorMessage = document.getElementById('error-message');
        const errorCloseBtn = document.getElementById('error-close-btn');
        const modalLoginBtn = document.getElementById('modal-login-btn');
        const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
        const filters = document.querySelector('.filters');
        const connectionStatus = document.getElementById('connection-status');

        let user = null;
        let userRoles = [];
        let drops = [];
        let socket = null;

        document.addEventListener('DOMContentLoaded', () => {
            checkAuth();
            setupEventListeners();
            setupFilters();
            setupCopyButtons();
            setupModalClosing();
            setupMobileMenu();
            processAuthResponse();
            setupWebSocket();
        });

        // Configurar WebSocket
        function setupWebSocket() {
            try {
                socket = io(BACKEND_URL, {
                    transports: ['websocket', 'polling']
                });

                socket.on('connect', () => {
                    connectionStatus.textContent = '✅ Conectado';
                    connectionStatus.classList.add('connected');
                });

                socket.on('disconnect', () => {
                    connectionStatus.textContent = '❌ Desconectado';
                    connectionStatus.classList.remove('connected');
                });

                socket.on('new-drop', (dropData) => {
                    drops.unshift(dropData);
                    renderDrops();
                });

                socket.on('drop-deleted', (dropId) => {
                    drops = drops.filter(drop => drop.id !== dropId);
                    renderDrops();
                });

            } catch (error) {
                console.error('Erro ao conectar WebSocket:', error);
            }
        }

        function setupEventListeners() {
            if (loginBtn) {
                loginBtn.addEventListener('click', () => {
                    if (user) {
                        logout();
                    } else {
                        loginModal.style.display = 'flex';
                        document.body.style.overflow = 'hidden';
                    }
                });
            }
            if (modalLoginBtn) {
                modalLoginBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    loginWithDiscord();
                });
            }
        }

        function setupModalClosing() {
            document.addEventListener('click', (e) => {
                if (e.target === loginModal) {
                    loginModal.style.display = 'none';
                    document.body.style.overflow = 'auto';
                }
                if (e.target === errorModal) {
                    errorModal.style.display = 'none';
                    document.body.style.overflow = 'auto';
                }
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    loginModal.style.display = 'none';
                    errorModal.style.display = 'none';
                    document.body.style.overflow = 'auto';
                }
            });
            if (errorCloseBtn) {
                errorCloseBtn.addEventListener('click', () => {
                    errorModal.style.display = 'none';
                    document.body.style.overflow = 'auto';
                });
            }
        }

        function setupMobileMenu() {
            if (mobileMenuBtn && filters) {
                mobileMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    filters.classList.toggle('active');
                });
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.filters') && !e.target.closest('.mobile-menu-btn')) {
                        filters.classList.remove('active');
                    }
                });
                window.addEventListener('resize', () => {
                    if (window.innerWidth > 768) {
                        filters.classList.remove('active');
                    }
                });
            }
        }

        function setupCopyButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('copy-btn')) {
                    const value = e.target.getAttribute('data-value');
                    navigator.clipboard.writeText(value);
                }
            });
        }

        function setupFilters() {
            const filterBtns = document.querySelectorAll('.filter-btn');
            filterBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    filterBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    renderDrops(btn.dataset.filter);
                });
            });
        }

        function checkAuth() {
            const token = localStorage.getItem('discord_token');
            const userData = localStorage.getItem('discord_user');
            const rolesData = localStorage.getItem('discord_roles');
            
            if (token && userData) {
                user = JSON.parse(userData);
                if (rolesData) userRoles = JSON.parse(rolesData);
                if (userRoles.length > 0) {
                    updateUIAfterLogin();
                    loadDrops();
                } else {
                    checkUserRoles(token);
                }
            } else {
                showNoAccessMessage();
            }
        }

        function loginWithDiscord() {
            window.location.href = `${BACKEND_URL}/auth/discord`;
        }

        function processAuthResponse() {
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const error = urlParams.get('error');
            
            if (error) {
                showError("Erro ao fazer login. Tente novamente.");
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }
            if (token) {
                localStorage.setItem('discord_token', token);
                getUserInfo(token);
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }

        async function getUserInfo(token) {
            try {
                const response = await fetch(`${BACKEND_URL}/api/user-info`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (!data.canAccess) {
                        showError("Você precisa ser membro do servidor.");
                        logout();
                        return;
                    }
                    user = { id: data.userId, username: data.username, avatar: data.avatar };
                    userRoles = data.roles;
                    localStorage.setItem('discord_user', JSON.stringify(user));
                    localStorage.setItem('discord_roles', JSON.stringify(userRoles));
                    updateUIAfterLogin();
                    loadDrops();
                }
            } catch (error) {
                console.error('Erro:', error);
                logout();
            }
        }

        function updateUIAfterLogin() {
            loginBtn.textContent = 'Sair';
            if (user.avatar) {
                userAvatar.src = `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.png?size=128`;
            }
            username.textContent = user.username;
            userInfo.classList.remove('hidden');
            loginModal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function logout() {
            localStorage.removeItem('discord_token');
            localStorage.removeItem('discord_user');
            localStorage.removeItem('discord_roles');
            user = null;
            userRoles = [];
            loginBtn.textContent = 'Entrar com Discord';
            userInfo.classList.add('hidden');
            clearDrops();
            showNoAccessMessage();
            if (socket) {
                socket.disconnect();
                connectionStatus.textContent = '❌ Desconectado';
                connectionStatus.classList.remove('connected');
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorModal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        async function loadDrops() {
            try {
                const token = localStorage.getItem('discord_token');
                if (!token) { showNoAccessMessage(); return; }
                const response = await fetch(`${BACKEND_URL}/api/drops`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (response.ok) {
                    const data = await response.json();
                    drops = data.success ? data.drops : [];
                }
            } catch (error) {
                drops = [];
            }
            renderDrops();
        }

        function renderDrops(filter = 'all') {
            clearDrops();
            if (!user || userRoles.length === 0) { showNoAccessMessage(); return; }
            const canSeeVip = userRoles.includes(VIP_ROLE_ID) || userRoles.includes(OWNER_ROLE_ID);
            const isOwner = userRoles.includes(OWNER_ROLE_ID);
            let filteredDrops = drops;
            if (filter === 'normal') filteredDrops = drops.filter(d => !d.isVip);
            else if (filter === 'vip') {
                if (!canSeeVip) { showNoDropsMessage(filter); return; }
                filteredDrops = drops.filter(d => d.isVip);
            }
            if (filteredDrops.length === 0) { showNoDropsMessage(filter); return; }
            filteredDrops.forEach(drop => dropsGrid.appendChild(createRobloxAccountElement(drop, isOwner)));
        }

        // CORRIGIDO: Aceita dados simples
        function createRobloxAccountElement(account, isOwner) {
            const card = document.createElement('div');
            card.className = 'drop-card';
            card.dataset.id = account.id;

            const username = account.username || "Conta Roblox";
            const robux = account.robux || "0";
            const age = account.age || "";
            const description = account.description || account.message || account.content || "Sem descrição disponível.";
            const features = account.features && Array.isArray(account.features) && account.features.length > 0
                ? account.features
                : [ "Drop recebido via Discord" ];
            const imageUrl = account.imageUrl || "https://via.placeholder.com/300x160/5865F2/FFFFFF?text=Roblox+Drop";
            const isVipOnly = account.isVip || false;

            card.innerHTML = `
                ${isVipOnly ? '<div class="vip-badge">VIP</div>' : '<div class="drop-badge">ROBLOX</div>'}
                <img src="${imageUrl}" alt="${username}" class="drop-image">
                <div class="drop-content">
                    <h3 class="drop-title">${username}</h3>
                    <div class="drop-price">${robux} Robux ${age ? '• ' + age : ''}</div>
                    <ul class="drop-features">${features.map(f => `<li>${f}</li>`).join('')}</ul>
                    <div class="account-credentials">
                        <div class="credential-item">
                            <span>Usuário: </span>
                            <span class="credential-value">${username}</span>
                            <button class="copy-btn" data-value="${username}">Copiar</button>
                        </div>
                        <div class="credential-item">
                            <span>Senha: </span>
                            <span class="credential-value">${account.password ? "••••••••" : "Não fornecida"}</span>
                            ${account.password ? `<button class="copy-btn" data-value="${account.password}">Copiar</button>` : ""}
                        </div>
                        <div class="credential-item">
                            <span>Cookie: </span>
                            <span class="credential-value">${account.cookie ? "••••••••" : "Não fornecido"}</span>
                            ${account.cookie ? `<button class="copy-btn" data-value="${account.cookie}">Copiar</button>` : ""}
                        </div>
                    </div>
                    <p class="drop-description">${description}</p>
                    <div class="drop-footer">
                        <button class="claim-btn">Resgatar Agora</button>
                        ${isOwner ? '<button class="delete-btn">🗑️</button>' : ''}
                    </div>
                </div>
            `;

            const claimBtn = card.querySelector('.claim-btn');
            claimBtn.addEventListener('click', () => {
                alert(`Você está resgatando a conta: ${username}\n${robux} Robux`);
            });
            if (isOwner) {
                const deleteBtn = card.querySelector('.delete-btn');
                deleteBtn.addEventListener('click', () => {
                    if (confirm(`Tem certeza que deseja deletar "${username}"?`)) {
                        deleteDrop(account.id);
                    }
                });
            }
            return card;
        }

        async function deleteDrop(dropId) {
            try {
                const token = localStorage.getItem('discord_token');
                await fetch(`${BACKEND_URL}/api/drops/${dropId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                drops = drops.filter(d => d.id !== dropId);
                renderDrops();
            } catch (e) {
                showError('Erro ao deletar');
            }
        }

        function clearDrops() { dropsGrid.innerHTML = ''; }

        function showNoAccessMessage() {
            dropsGrid.innerHTML = `
                <div class="no-drops">
                    <h3>Acesso Restrito</h3>
                    <p>Você precisa ser membro do servidor para visualizar os drops.</p>
                    <button class="login-btn" style="margin-top: 15px;">Entrar com Discord</button>
                </div>
            `;
        }

        function showNoDropsMessage(filter = 'all') {
            dropsGrid.innerHTML = `
                <div class="no-drops">
                    <h3>Nenhuma conta disponível</h3>
                    <p>${filter === 'vip' ? 'Você precisa ser VIP para ver contas VIP.' : 'Volte mais tarde!'}</p>
                </div>
            `;
        }
    </script>
</body>
</html>
